\section{Introduction}
\emph{Racing} is used to push the development, verification and validation of automated vehicles.
%
A \emph{racing task} may be fairly simple to specify, namely finishing laps as soon as possible, while remaining between the track boundaries.
%
Furthermore, static and dynamic obstacles may exist on the track, as in slalom or head-to-head racing.
%
This provides a semi-controlled environment to focus on lower-levels of automation such as path-planning, path-tracking, speed control, dynamic-obstacle avoidance, object detection and tracking, etc.
%
In a more complicated environment, such as an urban area or a high-way, more tasks and constraints are required.
%
For example, an automated vehicle may be required to route and deliver goods, ride passengers and customize the route to their needs, drive an emergency vehicle such as a fire truck as fast as possible, while following traffic rules and navigating around pedestrians and bicyclists safely.
%
The focus of this paper is on tasks in lower-levels of automation as in racing.


In recent years several autonomous racing competitions have emerged and sparked new directions in research.
%
For example, the F1/10 competition uses 1/10 scale autonomous vehicles, the Indy Autonomous Challenge uses full-scale race cars, and the Generalized RAcing Intelligence Competition (GRAIC) is a simulation-only race with challenging dynamic-obstacle avoidance scenarios.
%
A minimal requirement for such racing tasks is \emph{safety} and \emph{progress}.
%
Here \emph{safety} means avoiding obstacles and remaining within the track limits, while \emph{progress} means finishing one or more laps.
%
Furthermore, the \emph{performance} requirement is to make progress faster than other competitors in order to win a race.
%
In this paper we focus on the safety and progress requirements.


Our priority is to develop planning and control algorithms that not only can win competitions and push the performance, but also provably guarantee their safety, progress and performance.
%
We developed an algorithm that we implemented for both an F1/10 car and for the GRAIC competition.
%
Our implementation won the GRAIC competition.
%
In this paper, we briefly explain the algorithm, then dedicate the rest to its safety and progress analysis and proofs.
%
We leave the analysis of performance for future work.
%
While our planner can handle many static and dynamic obstacle scenarios, e.g. in the GRAIC competition, our guarantee proofs are only for obstacle-free racing such as in F1/10 time trials.


Our planning and control algorithm is \emph{map-less}.
%
That is, the algorithm is not given a map, neither it builds a map.
%
Furthermore, the algorithm is \emph{localization-less}, in the sense that the location of the vehicle relative to its final goal is not given, e.g. in contrast to using a GPS sensor.
%
In particular, we use a perception-planning-control loop where the perception operates solely on the latest data from the on-board LiDAR sensor, and the planner makes a plan in the local coordinates of the vehicle.
%
However, our guarantee proofs need the map of the track.


The LiDAR sensor gives a 2D point cloud measuring the boundaries of the track.
%
Our perception algorithm outputs a set of polylines approximating the point cloud.
%
Therefore, the planning algorithm's input is a polygonal model of the observed racing track.
%
Note that we can approximate curved track boundaries with polylines to any desired approximation error.
%
Our guarantees are on the planning and control parts only, and we ignore the perception algorithm in this paper.



We bridge the gap between local planning and global guarantees using mathematical properties of Voronoi diagrams.
%
Our planner computes the Voronoi diagram of the observed track boundaries, then plans a path based on the diagram.
%
We show that the plan would have been the same even if the sensor could observe the whole track, granted some conditions hold.
%
These sufficient conditions require some restrictions on the minimum and maximum width of the track relative to the range of LiDAR, wheelbase of the car, etc.


Our controller tracks the planned path using a pure-pursuit path-tracking algorithm.
%
Note that the trajectory of the vehicle is different from the planned path, since the vehicle is nonholonomic.
%
We need to guarantee that the trajectory is safe and that it makes progress.
%
We also need to prove that the trajectory satisfies the sufficient conditions assumed in the analysis of the planner.
%
The proof involves composing the dynamical model of the vehicle, with the planned path and the controller, to get a closed-loop hybrid dynamical system.
%
Then we can prove that if the car starts in an \emph{initial set}, say located around the start of the track and heading roughly towards the direction of the track, then it finishes the track safely within a bounded time horizon.
%
Using an inductive argument we can extend such a proof to an infinite time horizon and prove that a car can safely finish any number of laps on a circuit track.
%
On the other hand, we can strengthen the safety guarantee (no-collisions) to a guarantee of some minimum clearance from track boundaries.

