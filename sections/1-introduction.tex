\section{Introduction}
\emph{Racing} is used to push the development, verification and validation of automated vehicles.
%
A \emph{racing task} may be fairly simple to specify, namely finishing laps as soon as possible, while remaining between the track boundaries.
%
Furthermore, static and dynamic obstacles may exist on the track, as in slalom or head-to-head racing.
%
This provides a semi-controlled environment to focus on lower-levels of automation such as path-planning, path-tracking, speed control, dynamic-obstacle avoidance, object detection and tracking, etc.
%
In a more complicated environment, such as an urban area or a high-way, more tasks and constraints are required.
%
For example, an automated vehicle may be required to route and deliver goods, ride passengers and customize the route to their needs, drive an emergency vehicle such as a fire truck as fast as possible, while following traffic rules and navigating around pedestrians and bicyclists safely.
%
The focus of this paper is on tasks in lower-levels of automation as in racing.


In recent years several autonomous racing competitions have emerged and sparked new directions in research.
%
For example, the F1/10 competition uses 1/10 scale autonomous vehicles, the Indy Autonomous Challenge uses full-scale race cars, and the Generalized RAcing Intelligence Competition (GRAIC) is a simulation-only race with challenging dynamic-obstacle avoidance scenarios.
%
A minimal requirement for such racing tasks is \emph{safety} and \emph{progress}.
%
Here \emph{safety} means avoiding obstacles and remaining within the track limits, while \emph{progress} means finishing one or more laps.
%
Furthermore, the \emph{performance} requirement is to make progress faster than other competitors in order to win a race.
%
In this paper we focus on the safety and progress requirements.


Our priority is to develop planning and control algorithms that not only can win competitions and push the performance, but also provably guarantee their safety, progress and performance.
%
We developed an algorithm that we implemented for both an F1/10 car and for the GRAIC competition.
%
Our implementation won the GRAIC competition.
%
In this paper, we briefly explain the algorithm, then dedicate the rest to its safety and progress analysis and proofs.
%
We leave the analysis of performance for future work.
%
While our planner can handle many static and dynamic obstacle scenarios, e.g. in the GRAIC competition, our guarantee proofs are only for obstacle-free racing such as in F1/10 time trials.


Our planning and control algorithm is \emph{map-less}.
%
That is, the algorithm does not need an apriori given map, neither it builds a map.
%
In particular, we use a perception-planning-control loop where the perception operates solely on the latest on-board sensor data, and the planner makes a plan in the local coordinates of the vehicle.
%
However, our guarantee proofs are with respect to a given track and need the map of the track.
%
There are some advantages in not depending on maps or high-detail maps, and humans are capable of it.
%
Nevertheless, avoiding maps complicates the proof of \emph{progress} since the vehicle's plan is with respect to the local coordinates and not a global map.
%
We bridge this gap using mathematical properties of Voronoi diagrams.


Our perception algorithm relies solely on the measurements of a planar lidar sensor.
%
These measurements sense the boundaries of the track and are converted to a set of polylines approximating the 2D point cloud.
%
Therefore, the planning algorithm's input is a polygonal model of the racing track.
%
Note that we can approximate curved track boundaries with polylines to any desired approximation error.
%
Our guarantees are on the planning and control parts only, and we ignore the perception algorithm in this paper.
%
In return, our proof analysis is valid for any perception that outputs a polygonal model of the track, say detection of track boundaries using camera-based computer vision.


Our planner computes the Voronoi diagram of the track boundaries visible to the sensor, then plans a path based on the diagram.
%
We show that the plan would have been the same even if the sensor could see the whole track, if some conditions hold.
%
These sufficient conditions bridge the gap between local planning and global guarantees.


Our controller tracks the planned path using a pure-pursuit path-tracking algorithm.
%
Note that the trajectory of the vehicle is different from the planned path, since the vehicle is nonholonomic.
%
We need to guarantee that the trajectory is safe and that it makes progress.
%
We also need to prove that the trajectory satisfies the sufficient conditions assumed in the analysis of the planner.
%
The proof involves composing the dynamical model of the vehicle, with the planned path and the controller, to get a closed-loop hybrid dynamical system.
%
Then we can prove that if the car starts in an \emph{initial set}, say located around the start of the track and heading roughly towards the direction of the track, then it finishes the track safely within a bounded time horizon.
%
Using an inductive argument we can extend such a proof to an infinite time horizon and prove that a car can safely finish any number of laps on a circuit track.
%
On the other hand, we can strengthen the safety guarantee (no-collisions) to a guarantee of some minimum clearance from track boundaries.

